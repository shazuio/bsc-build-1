{"version":3,"sources":["../../../../../../src/constants/abi/index.ts","../../../../../src/hooks/useTokenBalance.ts","../../../../../src/hooks/useTokenAllowance.ts","../../../../../src/hooks/useChainState.ts","../../../../../src/hooks/useMulticallAddress.ts","../../../../../src/hooks/useEtherBalance.ts","../../../../../src/helpers/address.ts","../../../../../src/helpers/common.ts"],"names":["str"],"mappings":"spyCAAA,uHAOA,MAAM,EAAY,QAAM,UAElB,EAAe,IAAI,EAAU,EAAU,KAQvC,GAJgB,IAAI,EAAU,EAAW,KAIxB,IAAI,EAAU,EAAM,MAIhB,IAAI,EAAU,EAAU,M,kCCpBnD,mEAsBM,SAAU,EACd,EACA,GAC6B,IAA7B,yDAA2B,G,MAE3B,MAAQ,MAAO,GASZ,QARD,cACE,GACE,GAAgB,CACd,SAAU,IAAI,IAAS,EAAc,KACrC,OAAQ,YACR,KAAM,CAAC,IAEX,UACD,QAAI,GACP,OAAmB,OAAZ,QAAY,IAAZ,OAAY,EAAZ,EAAe,K,kCCrCxB,mEAwBM,SAAU,EACd,EACA,EACA,GAC6B,IAA7B,yDAA2B,G,MAE3B,MAAQ,MAAO,GAUZ,QATD,cACE,GACE,GACA,GAAgB,CACd,SAAU,IAAI,IAAS,EAAc,KACrC,OAAQ,YACR,KAAM,CAAC,EAAc,IAEzB,UACD,QAAI,GACP,OAAgB,OAAT,QAAS,IAAT,OAAS,EAAT,EAAY,K,2GClCf,SAAU,IACe,IAA7B,yDAA2B,GAE3B,MAAM,EAAkB,qBAAW,KAC7B,EAAU,YAAW,CAAE,gBAE7B,QAAgB,IAAZ,EAIJ,sCACK,EAAgB,OAAO,IAAQ,CAClC,cAAe,EAAgB,gBCZ7B,SAAU,IAAiD,IAA7B,yDAA2B,G,MAC7D,OAAiC,QAA1B,IAAc,UAAY,eAAE,iB,uBCa/B,SAAU,EAAgB,GAAsD,IAA7B,yDAA2B,G,MAClF,MAAM,EAAmB,EAAoB,IACrC,MAAO,GASZ,QARD,cACE,GACE,GAAW,CACT,SAAU,IAAI,IAAS,EAAkB,KACzC,OAAQ,gBACR,KAAM,CAAC,IAEX,UACD,QAAI,GACP,OAAY,OAAL,QAAK,IAAL,OAAK,EAAL,EAAQ,K,uFC1BX,SAAU,EAAe,GAC7B,IACE,MAAM,EAAmB,QAAM,WAAW,GAC1C,OCX0BA,EDWL,GCVZ,UAAU,EAAG,GAAK,MAAQ,EAAI,UAAU,EAAI,OAAS,GDW9D,SACA,MAAM,IAAI,UAAU,0CCblB,IAAwBA","file":"static/js/2.ae867adc.chunk.js","sourcesContent":["import { utils } from 'ethers';\nimport MultiCall from './MultiCall.json';\nimport MultiCall2 from './MultiCall2.json';\nimport ERC20 from './ERC20.json';\nimport ERC20Mock from './ERC20Mock.json';\nimport BlockNumberContract from './BlockNumber.json';\nconst Interface = utils.Interface;\nconst MultiCallABI = new Interface(MultiCall.abi);\nexport { MultiCall, MultiCallABI };\nconst MultiCall2ABI = new Interface(MultiCall2.abi);\nexport { MultiCall2, MultiCall2ABI };\nconst ERC20Interface = new Interface(ERC20.abi);\nexport { ERC20, ERC20Interface };\nconst ERC20MockInterface = new Interface(ERC20Mock.abi);\nexport { ERC20Mock, ERC20MockInterface };\nexport { BlockNumberContract };\nexport * from './doubler';\nexport * from './timestamp';\nexport * from './reverter';\n//# sourceMappingURL=index.js.map","import { Contract } from 'ethers';\nimport { ERC20Interface } from '../constants';\nimport { useCall } from './useCall';\n/**\n * Returns a balance of a given token for a given address.\n * @param tokenAddress address of a token contract.\n * @param address address of an account.\n * @param queryParams see {@link QueryParams}.\n * @public\n * @returns a balance which is `BigNumber`, or `undefined` if address or token is `Falsy` or not connected.\n * @example\n * const DAI_ADDRESS = '0x6b175474e89094c44da98b954eedeac495271d0f'\n * const { account } = useEthers()\n * const daiBalance = useTokenBalance(DAI_ADDRESS, account)\n *\n * return (\n *   {daiBalance && <p>Dai balance: {formatUnits(daiBalance, 18)} DAI</p>}\n * )\n */\nexport function useTokenBalance(tokenAddress, address, queryParams = {}) {\n    var _a;\n    const { value: tokenBalance } = (_a = useCall(address &&\n        tokenAddress && {\n        contract: new Contract(tokenAddress, ERC20Interface),\n        method: 'balanceOf',\n        args: [address],\n    }, queryParams)) !== null && _a !== void 0 ? _a : {};\n    return tokenBalance === null || tokenBalance === void 0 ? void 0 : tokenBalance[0];\n}\n//# sourceMappingURL=useTokenBalance.js.map","import { Contract } from 'ethers';\nimport { ERC20Interface } from '../constants';\nimport { useCall } from './useCall';\n/**\n * Returns allowance (tokens left to use by spender) for given token owner - spender relationship.\n * @param tokenAddress address of a token contract\n * @param ownerAddress address of an account to which tokens are linked\n * @param spenderAddress address of an account allowed to spend tokens\n * @param queryParams see {@link QueryParams}.\n * @returns an allowance which is `BigNumber`, or `undefined` if any address or token is `Falsy` or not connected.\n * @public\n * @example\n * const TOKEN_ADDRESS = '0x6b175474e89094c44da98b954eedeac495271d0f'\n * const SPENDER_ADDRESS = '0xA193E42526F1FEA8C99AF609dcEabf30C1c29fAA'\n * const { account, chainId } = useEthers()\n * const allowance = useTokenAllowance(TOKEN_ADDRESS, account, SPENDER_ADDRESS)\n *\n * return (\n *   {allowance && <p>Remaining allowance: {formatUnits(allowance, 18)} tokens</p>}\n * )\n */\nexport function useTokenAllowance(tokenAddress, ownerAddress, spenderAddress, queryParams = {}) {\n    var _a;\n    const { value: allowance } = (_a = useCall(ownerAddress &&\n        spenderAddress &&\n        tokenAddress && {\n        contract: new Contract(tokenAddress, ERC20Interface),\n        method: 'allowance',\n        args: [ownerAddress, spenderAddress],\n    }, queryParams)) !== null && _a !== void 0 ? _a : {};\n    return allowance === null || allowance === void 0 ? void 0 : allowance[0];\n}\n//# sourceMappingURL=useTokenAllowance.js.map","import { useContext } from 'react';\nimport { MultiChainStatesContext } from '../providers';\nimport { useChainId } from './useChainId';\n/**\n * @public\n */\nexport function useChainState(queryParams = {}) {\n    const multiChainState = useContext(MultiChainStatesContext);\n    const chainId = useChainId({ queryParams });\n    if (chainId === undefined) {\n        return undefined;\n    }\n    return Object.assign(Object.assign({}, multiChainState.chains[chainId]), { dispatchCalls: multiChainState.dispatchCalls });\n}\n//# sourceMappingURL=useChainState.js.map","import { useChainState } from './useChainState';\n/**\n * Returns an address of the multicall contract used on a given chain.\n * @public\n * @param queryParams see {@link QueryParams}.\n */\nexport function useMulticallAddress(queryParams = {}) {\n    var _a;\n    return (_a = useChainState(queryParams)) === null || _a === void 0 ? void 0 : _a.multicallAddress;\n}\n//# sourceMappingURL=useMulticallAddress.js.map","import { MultiCallABI } from '../constants';\nimport { useMulticallAddress } from './useMulticallAddress';\nimport { useCall } from './useCall';\nimport { Contract } from 'ethers';\n/**\n * Returns ether balance of a given account.\n * @param address address of an account\n * @returns a balance of the account which is BigNumber or `undefined` if not connected to network or address is a falsy value\n * @public\n *\n * @example\n * const { account } = useEthers()\n * const etherBalance = useEtherBalance(account)\n *\n * return (\n *   {etherBalance && <p>Ether balance: {formatEther(etherBalance)} ETH </p>}\n * )\n */\nexport function useEtherBalance(address, queryParams = {}) {\n    var _a;\n    const multicallAddress = useMulticallAddress(queryParams);\n    const { value: value } = (_a = useCall(multicallAddress &&\n        address && {\n        contract: new Contract(multicallAddress, MultiCallABI),\n        method: 'getEthBalance',\n        args: [address],\n    }, queryParams)) !== null && _a !== void 0 ? _a : {};\n    return value === null || value === void 0 ? void 0 : value[0];\n}\n//# sourceMappingURL=useEtherBalance.js.map","import { utils } from 'ethers';\nimport { BigNumber } from 'ethers';\nimport { shortenString } from './common';\n/**\n * @public\n */\nexport function shortenAddress(address) {\n    try {\n        const formattedAddress = utils.getAddress(address);\n        return shortenString(formattedAddress);\n    }\n    catch (_a) {\n        throw new TypeError(\"Invalid input, address can't be parsed\");\n    }\n}\n/**\n * @public\n */\nexport function shortenIfAddress(address) {\n    if (typeof address === 'string' && address.length > 0) {\n        return shortenAddress(address);\n    }\n    return '';\n}\n/**\n * @public\n */\nexport function compareAddress(firstAddress, secondAddress) {\n    try {\n        const parsedFirstAddress = BigNumber.from(firstAddress);\n        const parsedSecondAddress = BigNumber.from(secondAddress);\n        if (parsedFirstAddress.gt(parsedSecondAddress)) {\n            return 1;\n        }\n        if (parsedFirstAddress.lt(parsedSecondAddress)) {\n            return -1;\n        }\n        return 0;\n    }\n    catch (_a) {\n        throw new TypeError(\"Invalid input, address can't be parsed\");\n    }\n}\n/**\n * @public\n */\nexport function addressEqual(firstAddress, secondAddress) {\n    try {\n        return utils.getAddress(firstAddress) === utils.getAddress(secondAddress);\n    }\n    catch (_a) {\n        throw new TypeError(\"Invalid input, address can't be parsed\");\n    }\n}\n//# sourceMappingURL=address.js.map","export function shortenString(str) {\n    return str.substring(0, 6) + '...' + str.substring(str.length - 4);\n}\n//# sourceMappingURL=common.js.map"],"sourceRoot":""}